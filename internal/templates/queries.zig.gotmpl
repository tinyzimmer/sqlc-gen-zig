{{- $conf := .Config -}}
// Generated with sqlc {{ .SQLCVersion }}

const std = @import("std");
const Allocator = std.mem.Allocator;

const pg = @import("{{ .PGImportName }}");
{{ if hasEnums .Models }}
const enums = @import("{{ .EnumsFile }}");
{{- end }}
{{- if .Models }}
const models = @import("{{ .ModelsFile }}");
{{- end }}

pub const ConnQuerier = Querier(*pg.Conn);
pub const PoolQuerier = Querier(*pg.Pool);

pub fn Querier(comptime T: type) type {
    return struct {
        const Self = @This();
        {{ if and (not $conf.UnmanagedAllocations) (not $conf.UseContext) }}
        allocator: Allocator,
        {{- end }}
        conn: T,

        pub fn init({{ if and (not $conf.UnmanagedAllocations) (not $conf.UseContext) }}allocator: Allocator, {{ end }}conn: T) Self {
            return .{ {{ if and (not $conf.UnmanagedAllocations) (not $conf.UseContext) }}.allocator = allocator, {{ end }}.conn = conn };
        }
        {{ range $query := .Queries }}
        {{ if $conf.PublicQueryStings }}pub {{ end }}const {{ $query.ConstantName }} = 
            {{ multilineStringLiteral $query.SQL 12 }}
        ;
        {{- "\n" -}}
        {{- range $comment := $query.Comments }}
        // {{ $comment }}
        {{- end }}
        
        {{- /* Check if we are declaring a struct for the parameters of this query */}}
        {{- if hasLocalStructArg $query }}
        {{- range $arg := $query.Args }}
        {{- if $arg.Struct }}
        pub const {{ $arg.Struct.StructName }} = struct {
            {{- range $field := $arg.Struct.Fields }}
            {{ $field.Name }}: {{ if $field.Nullable }}?{{ end }}{{ if $field.Array }}[]{{ end }}{{ if and (isEnum $field) $field.Array }}const {{ end }}{{ $field.ZigType }}{{ if $field.Nullable }} = null{{ end }},
            {{- end }}
        };
        {{- "\n" -}}
        {{- end }}
        {{- end }}
        {{- end }}

        {{- /* Check if we are returning a custom struct from this query */}}
        {{- if and (and $query.Ret $query.Ret.Struct) $query.Ret.Emit }}
        pub const {{ $query.Ret.Struct.StructName }} = struct {
            {{- if and (hasNonScalarFields $query.Ret.Struct) (not $conf.UseContext) }}
            __allocator: Allocator,
            {{- "\n" -}}
            {{- end }}
            {{- range $field := $query.Ret.Struct.Fields }}
            {{- if $conf.UseContext }}
            {{ $field.Name }}: {{ if $field.Nullable }}?{{ end }}{{ if $field.Array }}*pg.Iterator({{ end }}{{ if and (isEnum $field) $field.Array }}[]const u8{{ else }}{{ $field.ZigType }}{{ end }}{{ if $field.Array }}){{ end }},
            {{- else }}
            {{ $field.Name }}: {{ if $field.Nullable }}?{{ end }}{{ if $field.Array }}[]{{ end }}{{ if and (isEnum $field) $field.Array }}const {{ end }}{{ $field.ZigType }}{{ if $field.Nullable }} = null{{ end }},
            {{- end }}
            {{- end }}

            {{- if and (hasNonScalarFields $query.Ret.Struct) (not $conf.UseContext) }}
            {{- "\n" }}
            pub fn deinit(self: *const {{ $query.Ret.Struct.StructName }}) void {
                {{- range $field := $query.Ret.Struct.Fields }}
                {{- if isNonScalar $field }}
                {{- if $field.Nullable }}
                if (self.{{ $field.Name }}) |field| {
                    {{- if eq $field.ZigType "pg.Cidr" }}
                    self.__allocator.free(field.address);
                    {{- else if eq $field.ZigType "pg.Numeric" }}
                    self.__allocator.free(field.digits);
                    {{- else }}
                    self.__allocator.free(field);
                    {{- end }}
                }
                {{- else }}
                {{- if eq $field.ZigType "pg.Cidr" }}
                self.__allocator.free(self.{{ $field.Name }}.address);
                {{- else if eq $field.ZigType "pg.Numeric" }}
                self.__allocator.free(self.{{ $field.Name }}.digits);
                {{- else }}
                self.__allocator.free(self.{{ $field.Name }});
                {{- end }}
                {{- end }}
                {{- end }}
                {{- end }}
            }
            {{- end }}
        };
        {{- "\n" -}}
        {{- end }}

        {{- /* Check if we are declaring a pg.Error union from this query, on exec queries */}}
        {{- if $conf.PGErrorUnions }}
        pub const {{ errorUnionType $query }} = union(enum) {
            {{ queryReturnID $query }}: {{if isManyQuery $query }}[]{{ end }}{{ queryReturnType $query }},
            pgerr: []const u8,

            pub fn err(self: @This()) ?pg.Error {
                switch (self) {
                    .{{ queryReturnID $query }} => return null,
                    .pgerr => return pg.Error.parse(self.pgerr),
                }
            }
        };
        {{- "\n" -}}
        {{- end }}

        {{- if $conf.UseContext }}
        pub fn {{ $query.MethodName }}({{ queryFuncArgs $conf $query }}) !void {
        {{- else }}
        pub fn {{ $query.MethodName }}({{ queryFuncArgs $conf $query }}) !{{ if $conf.PGErrorUnions }}{{ errorUnionType $query }}{{ else }}{{ if isManyQuery $query }}[]{{ end }}{{ queryReturnType $query }}{{ end }} {
        {{- end }}
            {{- if or (and (and $query.RequiresAllocations (not $conf.UnmanagedAllocations)) (not $conf.UseContext)) $conf.PGErrorUnions }}
            const allocator = self.allocator;
            {{- end }}
            var conn: *pg.Conn = blk: {
                if (T == *pg.Pool) {
                    break :blk try self.conn.acquire();
                } else {
                    break :blk self.conn;
                }
            };
            defer {
                if (T == *pg.Pool) {
                    self.conn.release(conn);
                }
            }
            {{ if not (isExecQuery $query) }}const result{{ else }}_{{ end }} = {{ if not $conf.PGErrorUnions }}try {{ end }}{{ callQueryFunc $query }}({{ $query.ConstantName }}, {{ queryExecParams $query 16 }}){{ if not $conf.PGErrorUnions }};{{ else }} catch |err| {
                if (conn.err) |_| {
                    return .{ .pgerr = try allocator.dupe(u8, conn._err_data orelse unreachable) };
                }
                return err;
            };{{ end }}
            {{- if not (isExecQuery $query) }}
            defer result.deinit();
            {{- else }}
            {{- if $conf.PGErrorUnions }}
            return .{ .ok = undefined };
            {{- end }}
            {{- end -}}

            {{- if $conf.UseContext }}
            {{- if isManyQuery $query }}
            {{- "\n" }}
            {{- include "scanManyQueryCallback" $query | indent 12 }}
            {{- else if isOneQuery $query }}
            {{- "\n" }}
            {{- include "scanOneQueryCallback" $query | indent 12 }}
            {{- end }}
            {{- else }}
            {{- if isManyQuery $query }}
            {{- "\n" }}
            {{- include "scanManyQuery" $query | indent 12 }}
            {{- if $conf.PGErrorUnions }}
            return .{
                .{{ queryReturnID $query }} = try out.toOwnedSlice(),
            };
            {{- else }}
            return try out.toOwnedSlice();
            {{- end }}
            {{- else if isOneQuery $query }}
            {{- "\n" }}
            {{- include "scanOneQuery" $query | indent 12 }}
            {{- if .Ret.Struct }}
            {{- if $conf.PGErrorUnions }}
            return .{
                .{{ queryReturnID $query }} = .{
                    {{- if hasNonScalarFields .Ret.Struct }}
                    .__allocator = allocator,
                    {{- end }}
                    {{- range $idx, $field := .Ret.Struct.Fields }}
                    .{{ $field.Name }} = {{ if $field.Array}}try {{ end }}row_{{ $field.Name }}{{ if $field.Array}}.toOwnedSlice(){{ end }},
                    {{- end }}
                }
            };
            {{- else }}
            return .{
                {{- if hasNonScalarFields .Ret.Struct }}
                .__allocator = allocator,
                {{- end }}
                {{- range $idx, $field := .Ret.Struct.Fields }}
                .{{ $field.Name }} = {{ if $field.Array}}try {{ end }}row_{{ $field.Name }}{{ if $field.Array}}.toOwnedSlice(){{ end }},
                {{- end }}
            };
            {{- end }}
            {{- else }}
            return {{ if $conf.PGErrorUnions }}.{ .{{ queryReturnID $query }} = row_{{ .Ret.Field.Name }}}{{ else }}row_{{ .Ret.Field.Name }}{{ end }};
            {{- end }}
            {{- end }}
            {{- end }}
        }
        {{- "\n" -}}
        {{- end }}
    };
}
