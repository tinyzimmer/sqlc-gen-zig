{{- define "scanOneQuery" -}}
const row = try result.next() orelse return error.NotFound;
{{- "\n" }}
{{- include "scanRow" . }}
{{- if .Ret.Struct }}
{{- "\n" }}
return .{
    {{- if hasNonScalarFields .Ret.Struct }}
    .__allocator = self.allocator,
    {{- end }}
    {{- range $idx, $field := .Ret.Struct.Fields }}
    .{{ $field.Name }} = row_{{ $field.Name }},
    {{- end }}
};
{{- else }}
// TODO: Scan into single value
{{- end }}
{{- end -}}

{{- define "scanManyQuery" -}}
var out = std.ArrayList({{ queryReturnType . }}).init(self.allocator);
defer out.deinit();
while (try result.next()) |row| {
    {{- include "scanRow" . | indent 4 }}
    {{- if .Ret.Struct }}
    try out.append(.{
        {{- if hasNonScalarFields .Ret.Struct }}
        .__allocator = self.allocator,
        {{- end }}
        {{- range $idx, $field := .Ret.Struct.Fields }}
        .{{ $field.Name }} = row_{{ $field.Name }},
        {{- end }}
    });
    {{- else -}}
    // TODO: Scan into single value
    {{- end }}
}
return try out.toOwnedSlice();
{{- end -}}

{{- define "scanRow" -}}
{{- if .Ret.Struct }}
{{- range $idx, $field := .Ret.Struct.Fields }}
{{- if isEnum $field }}
const row_{{ $field.Name }} = std.meta.stringToEnum({{ $field.ZigType }}, row.get([]const u8, {{ $idx }})){{ if not $field.Nullable }} orelse unreachable{{ end }};
{{- else if eq $field.ZigType "pg.Cidr" }}
const {{ $field.Name }}_cidr = row.get({{ if $field.Nullable }}?{{ end }}pg.Cidr, {{ $idx }});
{{- if $field.Nullable }}
const row_{{ $field.Name }}: ?pg.Cidr = blk: {
    if ({{ $field.Name }}_cidr) |cidr| {
        break :blk pg.Cidr{
            .address = try self.allocator.dupe(u8, cidr.address),
            .netmask = cidr.netmask,
            .family = cidr.family,
        };
    }
    break :blk null;
};
{{- else }}
const row_{{ $field.Name }} = pg.Cidr{
    .address = try self.allocator.dupe(u8, {{ $field.Name }}_cidr.address),
    .netmask = {{ $field.Name }}_cidr.netmask,
    .family = {{ $field.Name }}_cidr.family,
};
errdefer self.allocator.free(row_{{ $field.Name }}.address);
{{- end }}
{{- else if eq $field.ZigType "pg.Numeric" }}
const {{ $field.Name }}_numeric = row.get({{ if $field.Nullable }}?{{ end }}pg.Numeric, {{ $idx }});
{{- if $field.Nullable }}
const row_{{ $field.Name }}: ?pg.Numeric = blk: {
    if ({{ $field.Name }}_numeric) |numeric| {
        break :blk pg.Numeric{
            .number_of_digits = numeric.number_of_digits,
            .weight = numeric.weight,
            .sign = numeric.sign,
            .scale = numeric.scale,
            .digits = try self.allocator.dupe(u8, numeric.digits),
        };
    }
    break :blk null;
};
if (row_{{ $field.Name }}) |numeric| {
    errdefer self.allocator.free(numeric.digits);
}
{{- else }}
const row_{{ $field.Name }} = pg.Numeric{
    .number_of_digits = numeric.number_of_digits,
    .weight = numeric.weight,
    .sign = numeric.sign,
    .scale = numeric.scale,
    .digits = try self.allocator.dupe(u8, numeric.digits),
};
errdefer self.allocator.free(row_{{ $field.Name }}.digits);
{{- end }}
{{- else if isNonScalar $field }}
{{- if $field.Nullable }}
const maybe_{{ $field.Name }} = row.get(?{{ $field.ZigType }}, {{ $idx }});
const row_{{ $field.Name }}: ?{{ $field.ZigType }} = blk: {
    if (maybe_{{ $field.Name }}) |field| {
        break :blk try self.allocator.dupe({{ allocType $field }}, field);
    }
    break :blk null;
};
if (row_{{ $field.Name }}) |field| {
    errdefer self.allocator.free(field);
}
{{- else }}
const row_{{ $field.Name }} = try self.allocator.dupe({{ allocType $field }}, row.get({{ fieldScanType $field }}, {{ $idx }}));
errdefer self.allocator.free(row_{{ $field.Name }});
{{- end }}
{{- else }}
const row_{{ $field.Name }} = row.get({{ fieldScanType $field }}, {{ $idx }});
{{- end }}
{{- end }}
{{- else }}
// TODO: Scan into single value
{{- end -}}
{{- end -}}